package org.broadinstitute.monster.clinvar.parsed

import java.time.LocalDate

import org.broadinstitute.monster.clinvar.{Constants, Content}
import org.broadinstitute.monster.clinvar.jadeschema.table._
import upack.{Msg, Str}

/**
  * Wrapper for the fully-parsed contents of a single ClinVar VariationArchive.
  *
  * This representation flattens the hierarchy between models contained within
  * the archive. The parsing process must generate cross-links.
  *
  * @param variation        fully-parsed model about the variation described by the archive,
  *                         along with its associated genes
  * @param vcv              info about how `variation` was submitted to ClinVar and reviewed
  * @param vcvRelease       info about the release history of `vcv`
  * @param rcvs             records describing ClinVar's aggregate knowledge of `variation`
  * @param traitSets        info about collections of `vcvTraits`
  * @param traits           info about traits
  * @param traitMappings    info about how the members of `scvTraits` link to the
  *                         members of `vcvTraits`
  * @param scvs             fully-parsed submissions that contribute to the reference
  *                         info stored in the archive
  */
case class ParsedArchive(
  variation: ParsedVariation,
  vcv: Option[VariationArchive],
  vcvRelease: Option[VariationArchiveRelease],
  rcvs: Array[RcvAccession],
  traitSets: Array[TraitSet],
  traits: Array[Trait],
  traitMappings: Array[TraitMapping],
  scvs: Array[ParsedScv]
)

object ParsedArchive {
  import org.broadinstitute.monster.common.msg.MsgOps

  /** Type for "real" VCVs backed by submissions to ClinVar. */
  val InterpretedRecord: Msg = Str("InterpretedRecord")

  /**
    * Type for "fake" VCVs generated by ClinVar to model nested variations
    * which don't have their own top-level submissions.
    */
  val IncludedRecord: Msg = Str("IncludedRecord")

  /**
    * Convert a raw VariationArchive payload into our parsed form.
    *
    * This process assumes:
    *   1. The input payload was produced by running a ClinVar XML release
    * through Monster's XML->JSON conversion program
    *   2. Each VariationArchive is self-contained, and cross-links
    * can be fully constructed between all sub-models without
    * examining other archive instances
    */
  def fromRawArchive(rawArchive: Msg): ParsedArchive = {
    /*
     * ClinVar publishes two types of "record"s:
     *   1. InterpretedRecords are generated for each variation that is sent
     *      to ClinVar as the top-level focus of a clinical assertion. They
     *      are reviewed by experts, and therefore have ClinVar-specific
     *      provenance info attached to them.
     *   2. IncludedRecords are generated for variations that have never been
     *      the focus of a clinical assertion, but have been mentioned as
     *      descendants by other assertions (i.e. a SimpleAllele in a Haplotype).
     *      They aren't reviewed by experts, and have no meaningful ClinVar-
     *      specific provenance info.
     *
     * We want to collect the variation and gene info described by both types
     * of records.
     */
    val variationRecord = rawArchive.obj
      .get(InterpretedRecord)
      .orElse(rawArchive.obj.get(IncludedRecord))
      .getOrElse {
        throw new IllegalStateException(s"Found an archive with no record: $rawArchive")
      }

    val parsedVariation = ParsedVariation.fromRawRecord(variationRecord)

    // Since IncludedRecords don't contain meaningful provenance, we only
    // bother to do further processing for InterpretedRecords.
    if (rawArchive.obj.contains(InterpretedRecord)) {
      // Extract basic info about the archive.
      val vcvRelease = VariationArchiveRelease(
        variationArchiveId = rawArchive.extract[String]("@Accession"),
        version = rawArchive.extract[Long]("@Version"),
        releaseDate =
          rawArchive.extract[LocalDate]("ClinVarVariationRelease", "@ReleaseDate")
      )

      // Parse the variation's interpretation.
      val interpretation = ParsedInterpretation.fromRawInterpretation(
        variationRecord.extract[Msg]("Interpretations", "Interpretation")
      )

      // Pull out any RCVs, cross-linking to the relevant trait sets.
      val rcvs = variationRecord
        .tryExtract[Array[Msg]]("RCVList", "RCVAccession")
        .getOrElse(Array.empty)
        .map {
          parseRawRcv(
            parsedVariation.variation.id,
            vcvRelease.variationArchiveId,
            interpretation,
            _
          )
        }

      // Pull out SCV<->VCV trait mappings.
      val traitMappings = variationRecord
        .tryExtract[Array[Msg]]("TraitMappingList", "TraitMapping")
        .getOrElse(Array.empty)
        .map { rawMapping =>
          TraitMapping(
            clinicalAssertionId = rawMapping.extract[String]("@ClinicalAssertionID"),
            traitType = rawMapping.extract[String]("@TraitType"),
            mappingType = rawMapping.extract[String]("@MappingType"),
            mappingRef = rawMapping.extract[String]("@MappingRef"),
            mappingValue = rawMapping.extract[String]("@MappingValue"),
            medgenId = rawMapping.tryExtract[String]("MedGen", "@CUI").filter(_ != "None"),
            medgenName = rawMapping.tryExtract[String]("MedGen", "@Name")
          )
        }

      // Narrow the search space needed in future cross-linking by grouping
      // mappings by their SCV.
      //
      // NOTE: This grouping is done by numeric ID, not accession.
      // We have to post-process the trait mappings after looping through
      // the SCVs to fix up the references.
      val mappingsByScvId = traitMappings.groupBy(_.clinicalAssertionId)

      // Pull out any SCVs, and related info.
      val parsedScvs = variationRecord
        .tryExtract[Array[Msg]]("ClinicalAssertionList", "ClinicalAssertion")
        .getOrElse(Array.empty)
        .map {
          ParsedScv.fromRawAssertion(
            parsedVariation.variation.id,
            vcvRelease.variationArchiveId,
            rcvs,
            interpretation,
            mappingsByScvId,
            _
          )
        }

      // Swap SCV accessions for their numeric IDs so the FK in the mapping table
      // actually works.
      val mappingsWithAccessionLinks = traitMappings.map { rawMapping =>
        val matchingScv = parsedScvs
          .find(_.assertion.internalId == rawMapping.clinicalAssertionId)
          .getOrElse {
            throw new IllegalStateException(
              s"Can't link SCV ID ${rawMapping.clinicalAssertionId} to its accession"
            )
          }
        rawMapping.copy(clinicalAssertionId = matchingScv.assertion.id)
      }

      // Pull out top-level info about the VCV and combine it with summary
      // interpretation data.
      val vcv = VariationArchive(
        id = vcvRelease.variationArchiveId,
        version = vcvRelease.version,
        variationId = parsedVariation.variation.id,
        dateCreated = rawArchive.tryExtract[LocalDate]("@DateCreated"),
        dateLastUpdated = rawArchive.tryExtract[LocalDate]("@DateLastUpdated"),
        numSubmissions = rawArchive.tryExtract[Long]("@NumberOfSubmissions"),
        numSubmitters = rawArchive.tryExtract[Long]("@NumberOfSubmitters"),
        recordStatus = rawArchive.tryExtract[String]("RecordStatus", "$"),
        reviewStatus =
          rawArchive.tryExtract[String]("InterpretedRecord", "ReviewStatus", "$"),
        species = rawArchive.tryExtract[String]("Species", "$"),
        interpDateLastEvaluated = interpretation.dateLastEvaluated,
        interpType = interpretation.`type`,
        interpDescription = interpretation.description,
        interpExplanation = interpretation.explanation,
        interpContent = interpretation.content,
        content = Content.encode(rawArchive)
      )

      ParsedArchive(
        variation = parsedVariation,
        vcv = Some(vcv),
        vcvRelease = Some(vcvRelease),
        rcvs = rcvs,
        scvs = parsedScvs,
        traitSets = interpretation.traitSets,
        traits = interpretation.traits,
        traitMappings = mappingsWithAccessionLinks
      )
    } else {
      ParsedArchive(
        variation = parsedVariation,
        vcv = None,
        vcvRelease = None,
        rcvs = Array.empty,
        traitSets = Array.empty,
        traits = Array.empty,
        traitMappings = Array.empty,
        scvs = Array.empty
      )
    }
  }

  /**
    * Convert a raw RCVAccession payload into our model.
    *
    * @param variationId ID of the variation the RCV describes
    * @param vcvId ID of the archive containing the RCV
    * @param interpretation fully-parsed data about the variation's
    *                       interpreted effects
    * @param rawRcv payload to parse
    */
  def parseRawRcv(
    variationId: String,
    vcvId: String,
    interpretation: ParsedInterpretation,
    rawRcv: Msg
  ): RcvAccession = {
    // First locate which trait-set associated with the variation is linked to the
    // RCV's condition list.
    val relevantTraitSetId = {
      val relevantTraitIds = rawRcv
        .tryExtract[Array[Msg]]("InterpretedConditionList", "InterpretedCondition")
        .getOrElse(Array.empty)
        .flatMap { rawCondition =>
          val conditionDb = rawCondition.tryExtract[String]("@DB")
          val conditionId = rawCondition.tryExtract[String]("@ID")
          val conditionValue = rawCondition.extract[String]("$")

          if (conditionDb.contains(Constants.MedGenKey)) {
            interpretation.traits.find(_.medgenId == conditionId)
          } else {
            interpretation.traits.find(_.name.contains(conditionValue))
          }
        }
        .map(_.id)
        .toSet

      interpretation.traitSets.find(_.traitIds.toSet == relevantTraitIds).map(_.id)
    }

    RcvAccession(
      id = rawRcv.extract[String]("@Accession"),
      version = rawRcv.extract[Long]("@Version"),
      variationId = variationId,
      variationArchiveId = vcvId,
      title = rawRcv.tryExtract[String]("@Title"),
      dateLastEvaluated = rawRcv.tryExtract[LocalDate]("@DateLastEvaluated"),
      reviewStatus = rawRcv.tryExtract[String]("@ReviewStatus"),
      interpretation = rawRcv.tryExtract[String]("@Interpretation"),
      submissionCount = rawRcv.tryExtract[Long]("@SubmissionCount"),
      independentObservations = rawRcv.tryExtract[Long]("@independentObservations"),
      traitSetId = relevantTraitSetId,
      content = Content.encode(rawRcv)
    )
  }
}
