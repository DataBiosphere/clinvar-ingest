package org.broadinstitute.monster.clinvar.parsers

import java.time.LocalDate

import org.broadinstitute.monster.clinvar.{Constants, Content}
import org.broadinstitute.monster.clinvar.jadeschema.table._
import upack.{Msg, Str}

/**
  * Wrapper for the fully-parsed contents of a single ClinVar VariationArchive.
  *
  * This representation flattens the hierarchy between models contained within
  * the archive. The parsing process must generate cross-links.
  *
  * @param variation        fully-parsed model about the variation described by the archive,
  *                         along with its associated genes
  * @param vcv              info about how `variation` was submitted to ClinVar and reviewed
  * @param rcvs             records describing ClinVar's aggregate knowledge of `variation`
  * @param traitSets        info about collections of `vcvTraits`
  * @param traits           info about traits
  * @param traitMappings    info about how the members of `scvTraits` link to the
  *                         members of `vcvTraits`
  * @param scvs             fully-parsed submissions that contribute to the reference
  *                         info stored in the archive
  */
case class VCV(
  variation: Variation,
  vcv: Option[VariationArchive],
  rcvs: List[RcvAccession],
  traitSets: List[TraitSet],
  traits: List[Trait],
  traitMappings: List[TraitMapping],
  scvs: List[SCV]
)

object VCV {
  import org.broadinstitute.monster.common.msg.MsgOps

  /**
    * Interface for a utility which can convert raw VariationArchives into
    * our target schema.
    */
  trait Parser extends Serializable {

    /**
      * Convert a raw VariationArchive payload into our parsed form.
      *
      * This process assumes:
      *   1. The input payload was produced by running a ClinVar XML release
      * through Monster's XML->JSON conversion program
      *   2. Each VariationArchive is self-contained, and cross-links
      * can be fully constructed between all sub-models without
      * examining other archive instances
      */
    def parse(rawArchive: Msg): VCV
  }

  /** Type for "real" VCVs backed by submissions to ClinVar. */
  val InterpretedRecord: Msg = Str("InterpretedRecord")

  /**
    * Type for "fake" VCVs generated by ClinVar to model nested variations
    * which don't have their own top-level submissions.
    */
  val IncludedRecord: Msg = Str("IncludedRecord")

  /** Parser for "real" VariationArchive payloads, to be used in production. */
  def parser(
    releaseDate: LocalDate,
    variationParser: Variation.Parser,
    interpParser: Interpretation.Parser,
    scvParser: SCV.Parser
  ): Parser = rawArchive => {
    /*
     * ClinVar publishes two types of "record"s:
     *   1. InterpretedRecords are generated for each variation that is sent
     *      to ClinVar as the top-level focus of a clinical assertion. They
     *      are reviewed by experts, and therefore have ClinVar-specific
     *      provenance info attached to them.
     *   2. IncludedRecords are generated for variations that have never been
     *      the focus of a clinical assertion, but have been mentioned as
     *      descendants by other assertions (i.e. a SimpleAllele in a Haplotype).
     *      They aren't reviewed by experts, and have no meaningful ClinVar-
     *      specific provenance info.
     *
     * We want to collect the variation and gene info described by both types
     * of records.
     */
    val variationRecord = rawArchive.obj
      .get(InterpretedRecord)
      .orElse(rawArchive.obj.get(IncludedRecord))
      .getOrElse {
        throw new IllegalStateException(s"Found an archive with no record: $rawArchive")
      }

    val parsedVariation = variationParser.parse(variationRecord)

    // Since IncludedRecords don't contain meaningful provenance, we only
    // bother to do further processing for InterpretedRecords.
    val recordType = rawArchive.extract[String]("@RecordType")
    if (recordType == "interpreted") {
      // Pop out fields already covered by the variation tree.
      val _ = List("@VariationID", "@VariationName", "@VariationType")
        .foreach(rawArchive.tryExtract[Msg](_))

      val vcvId = rawArchive.extract[String]("@Accession")

      // Parse the variation's interpretation.
      val interpretation =
        interpParser.parse(variationRecord.extract[Msg]("Interpretations", "Interpretation"))

      // Pull out any RCVs, cross-linking to the relevant trait sets.
      val rcvs = variationRecord
        .tryExtract[List[Msg]]("RCVList", "RCVAccession")
        .getOrElse(Nil)
        .map {
          parseRawRcv(
            releaseDate,
            parsedVariation.variation.id,
            vcvId,
            interpretation,
            _
          )
        }

      // Pull out SCV<->VCV trait mappings.
      val traitMappings = variationRecord
        .tryExtract[List[Msg]]("TraitMappingList", "TraitMapping")
        .getOrElse(Nil)
        .map { rawMapping =>
          TraitMapping(
            clinicalAssertionId = rawMapping.extract[String]("@ClinicalAssertionID"),
            traitType = rawMapping.extract[String]("@TraitType"),
            mappingType = rawMapping.extract[String]("@MappingType"),
            mappingRef = rawMapping.extract[String]("@MappingRef"),
            mappingValue = rawMapping.extract[String]("@MappingValue"),
            releaseDate = releaseDate,
            medgenId = rawMapping.tryExtract[String]("MedGen", "@CUI").filter(_ != "None"),
            medgenName = rawMapping.tryExtract[String]("MedGen", "@Name")
          )
        }

      // Narrow the search space needed in future cross-linking by grouping
      // mappings by their SCV.
      //
      // NOTE: This grouping is done by numeric ID, not accession.
      // We have to post-process the trait mappings after looping through
      // the SCVs to fix up the references.
      val mappingsByScvId = traitMappings.groupBy(_.clinicalAssertionId)

      // Pull out any SCVs, and related info.
      val scvContext = SCV.ParsingContext(
        parsedVariation.variation.id,
        vcvId,
        rcvs,
        interpretation,
        mappingsByScvId
      )
      val parsedScvs = variationRecord
        .tryExtract[List[Msg]]("ClinicalAssertionList", "ClinicalAssertion")
        .getOrElse(Nil)
        .map(scvParser.parse(scvContext, _))

      // Swap SCV accessions for their numeric IDs so the FK in the mapping table
      // actually works.
      val mappingsWithAccessionLinks = traitMappings.map { rawMapping =>
        val matchingScv = parsedScvs
          .find(_.assertion.internalId == rawMapping.clinicalAssertionId)
          .getOrElse {
            throw new IllegalStateException(
              s"Can't link SCV ID ${rawMapping.clinicalAssertionId} to its accession"
            )
          }
        rawMapping.copy(clinicalAssertionId = matchingScv.assertion.id)
      }

      // Pull out top-level info about the VCV and combine it with summary
      // interpretation data.
      val vcv = VariationArchive(
        id = vcvId,
        releaseDate = releaseDate,
        version = rawArchive.extract[Long]("@Version"),
        variationId = parsedVariation.variation.id,
        dateCreated = rawArchive.tryExtract[LocalDate]("@DateCreated"),
        dateLastUpdated = rawArchive.tryExtract[LocalDate]("@DateLastUpdated"),
        numSubmissions = rawArchive.tryExtract[Long]("@NumberOfSubmissions"),
        numSubmitters = rawArchive.tryExtract[Long]("@NumberOfSubmitters"),
        recordStatus = rawArchive.tryExtract[String]("RecordStatus", "$"),
        reviewStatus = rawArchive.tryExtract[String]("InterpretedRecord", "ReviewStatus", "$"),
        species = rawArchive.tryExtract[String]("Species", "$"),
        interpDateLastEvaluated = interpretation.dateLastEvaluated,
        interpType = interpretation.`type`,
        interpDescription = interpretation.description,
        interpExplanation = interpretation.explanation,
        interpContent = interpretation.content,
        content = Content.encode(rawArchive)
      )

      VCV(
        variation = parsedVariation,
        vcv = Some(vcv),
        rcvs = rcvs,
        scvs = parsedScvs,
        traitSets = interpretation.traitSets,
        traits = interpretation.traits,
        traitMappings = mappingsWithAccessionLinks
      )
    } else {
      VCV(
        variation = parsedVariation,
        vcv = None,
        rcvs = Nil,
        traitSets = Nil,
        traits = Nil,
        traitMappings = Nil,
        scvs = Nil
      )
    }
  }

  /**
    * Convert a raw RCVAccession payload into our model.
    *
    * @param variationId ID of the variation the RCV describes
    * @param vcvId ID of the archive containing the RCV
    * @param interpretation fully-parsed data about the variation's
    *                       interpreted effects
    * @param rawRcv payload to parse
    */
  def parseRawRcv(
    releaseDate: LocalDate,
    variationId: String,
    vcvId: String,
    interpretation: Interpretation,
    rawRcv: Msg
  ): RcvAccession = {
    // First locate which trait-set associated with the variation is linked to the
    // RCV's condition list.
    val relevantTraitSetId = {
      val relevantTraitIds = rawRcv
        .tryExtract[List[Msg]]("InterpretedConditionList", "InterpretedCondition")
        .getOrElse(Nil)
        .flatMap { rawCondition =>
          val conditionDb = rawCondition.tryExtract[String]("@DB")
          val conditionId = rawCondition.tryExtract[String]("@ID")
          val conditionValue = rawCondition.extract[String]("$")

          if (conditionDb.contains(Constants.MedGenKey)) {
            interpretation.traits.find(_.medgenId == conditionId)
          } else {
            interpretation.traits.find(_.name.contains(conditionValue))
          }
        }
        .map(_.id)
        .toSet

      interpretation.traitSets.find(_.traitIds.toSet == relevantTraitIds).map(_.id)
    }

    RcvAccession(
      id = rawRcv.extract[String]("@Accession"),
      releaseDate = releaseDate,
      version = rawRcv.extract[Long]("@Version"),
      variationId = variationId,
      variationArchiveId = vcvId,
      title = rawRcv.tryExtract[String]("@Title"),
      dateLastEvaluated = rawRcv.tryExtract[LocalDate]("@DateLastEvaluated"),
      reviewStatus = rawRcv.tryExtract[String]("@ReviewStatus"),
      interpretation = rawRcv.tryExtract[String]("@Interpretation"),
      submissionCount = rawRcv.tryExtract[Long]("@SubmissionCount"),
      independentObservations = rawRcv.tryExtract[Long]("@independentObservations"),
      traitSetId = relevantTraitSetId,
      content = Content.encode(rawRcv)
    )
  }
}
